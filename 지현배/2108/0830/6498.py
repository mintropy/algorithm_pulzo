import sys
input = sys.stdin.readline
while True:
    N = int(input())
    if N == 0: break
    C = list(map(int, input().split()))
    dp = [[0 for _ in range(N + 1)]] + [[sys.maxsize for _ in range(N + 1)] for _ in range(N)]
    # 0 ~ n 구간에서의 최솟값을 찾는다.
    for i in range(N):
        sum = 0
        # n부터 역순으로 값을 누적하면서
        # 그 이전까지의 값을 더하여
        # dp를 작은 것으로 갱신한다.
        for j in range(i, 0, -1):
            sum += C[j]
            # k만큼 누적과 그 이전의 값을 더한 후, 기존 dp 값과 비교한다.
            for k in range(1, j + 1):
                # i + 1 = 비트 수, k + 1 = prefix 길이
                dp[i + 1][k + 1] = min(dp[i + 1][k + 1], dp[j][k] + sum * (i + k + 2))
        # 처음부터 끝까지 누적한 결과를 가장 앞에 넣는다. prefix 길이는 1(k = 0)
        dp[i + 1][1] = (sum + C[0]) * (i + 2)
    # 결과는 전체 n 구간에서의 dp 최솟값이다.
    print(min(dp[-1]))


#   1   2   3   4   5   6   7   8   9  10  11 비트 수
#  44 100 196 222 295 375 452 502 535 551 629 누적
# 629 585 529 433 407 334 254 177 127  94  78 역 누적
#  44  56  96  26  73  80  77  50  33  16  78 Ci
#   1   2   3   4   5   6   7   8   9  10  11 prefix
#   2   4   6   8  10  12  14  16  18  20  22 코드 길이
#  88 112 576 104 730 9601078 800 594 3201716 7078







#   0   0   0   0   0 375   0 127   0   0 127
#                       7      10          14
#                    2625    1270        1778 5673
#   0   0   0   0   0 375   0   0 160   0  94
#                       7          11      14
#                    2625        1760    1316 5701
#   0   0   0   0 295   0 157   0  83   0  94
#                   6       9      12      15
#                1770    1413     996    1410 5589
# 452  83  94
#   8  11  14
#3616 9131316
#   0   0   0 222   0   0 234   0  83   0  94
#               5           9      12      15
#            1110        2106     996    1410
# 254
#  13

#      33 11   16 13    78 15
#      16 12   